parameters:
  name: ''
  # send telemetry
  enableTelemetry: true
  # install Microbuild plugin if not a public build
  enableMicrobuild: true
  queue: {}
  variables: {}

# Common conditionals:  There are a number of common conditionals that are useful.  Generally these are used to decide what resources can be accessed,
#                       or what logic should be applied based on the context the build is being run in.
#   - eq(ne(variables['Agent.Os'], 'Windows_NT') - Running/not running on a windows machine
#   - eq(ne(variables['System.TeamProject'], 'public') - Running/not running on the dotnet public VSTS project 
#   - and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest') - Not running in public and not a pull request.
#   - or(eq(variables['System.TeamProject'], 'public'), in(variables['Build.Reason'], 'PullRequest') - Running in public or a pull request.

phases:
- template: /eng/common/templates/phases/base.yml
  parameters:
    enableTelemetry: ${{ parameters.enableTelemetry }}

    enableMicrobuild: ${{ parameters.enableMicrobuild }}

    name: ${{ parameters.name }}

    queue: ${{ parameters.queue }}

    variables: 
      ${{ insert }}: ${{ parameters.variables }}
      _HelixBuildConfig: $(_BuildConfig)
      # Only enable publishing in non-public, non PR scenarios.
      # TODO: Once we go public, remove the build definition name check
      ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), not(contains(variables['Build.DefinitionName'], 'github'))) }}:
        # This should be changed to an isolated blob feed per-build.
        # Right now a manual build of a random branch would get published alongside the normal branch artifacts.
        _PublishBlobFeedUrl: https://dotnetfeed.blob.core.windows.net/dotnet-core/index.json
        _SignArgs: /p:DotNetSignType=$(_SignType) /p:TeamName=$(_TeamName)
        _PublishArgs: /p:DotNetPublishBlobFeedKey=$(dotnetfeed-storage-access-key-1) 
          /p:DotNetPublishBlobFeedUrl=$(_PublishBlobFeedUrl) 
          /p:DotNetPublishToBlobFeed=$(_DotNetPublishToBlobFeed)
          /p:DotNetSymbolServerTokenMsdl=$(microsoft-symbol-server-pat)
          /p:DotNetSymbolServerTokenSymWeb=$(symweb-symbol-server-pat)
        _OfficialBuildIdArgs: /p:OfficialBuildId=$(BUILD.BUILDNUMBER)
      # else
      # TODO: Once we go public, remove the build definition name check
      ${{ if or(eq(variables['System.TeamProject'], 'public'), in(variables['Build.Reason'], 'PullRequest'), contains(variables['Build.DefinitionName'], 'github')) }}:
        _PublishArgs: ''
        _OfficialBuildIdArgs: ''
        _SignArgs: ''

    steps:
    # TODO: Once we go public, remove the build definition name check
    - ${{ if and(ne(variables['System.TeamProject'], 'public'), notin(variables['Build.Reason'], 'PullRequest'), not(contains(variables['Build.DefinitionName'], 'github'))) }}:
        - task: AzureKeyVault@1
          inputs:
            azureSubscription: 'DotNet-Engineering-Services_KeyVault'
            KeyVaultName: EngKeyVault
            SecretsFilter: 'dotnetfeed-storage-access-key-1,microsoft-symbol-server-pat,symweb-symbol-server-pat'

    # Use utility script to run script command dependent on agent OS.
    - script: eng\common\cibuild.cmd
        -configuration $(_BuildConfig) 
        -prepareMachine
        $(_PublishArgs)
        $(_SignArgs)
        $(_OfficialBuildIdArgs)
      displayName: Windows Build / Publish
      condition: and(succeeded(), eq(variables['Agent.Os'], 'Windows_NT'))

    # prepare the helix package
    - task: CopyFiles@2
      displayName: Copy test binaries to helix payload dir
      inputs:
        sourceFolder: $(Build.SourcesDirectory)/artifacts/bin/System.Windows.Forms.Tests/$(_BuildConfig)/netcoreapp2.0
        contents: '**'
        targetFolder: $(Build.StagingDirectory)/helixPayload
        overWrite: true
      condition: succeeded()

    - task: CopyFiles@2
      displayName: Copy xunit.runner.console to helix payload dir
      inputs:
        sourceFolder: $(Build.SourcesDirectory)/.packages/xunit.runner.console/2.4.1-pre.build.4059/tools/netcoreapp2.0
        contents: '**'
        targetFolder: $(Build.StagingDirectory)/helixPayload
        overWrite: true
      condition: succeeded()

    # send the unit tests to helix
    - template: /eng/common/templates/steps/helix-publish.yml
      parameters:
        HelixSource: $(_HelixSource)
        HelixType: type/tests
        HelixTargetQueues: Windows.10.Amd64.Open
        HelixAccessToken: $(helix-token)
        # HelixPreCommands: '' -- any commands that you would like to run prior to running your job
        # HelixPostCommands: '' -- any commands that you would like to run after running your job
        WorkItemDirectory: $(Build.StagingDirectory)/helixPayload
        WorkItemCommand: 'dotnet exec --depsfile System.Windows.Forms.Tests.deps.json --runtimeconfig System.Windows.Forms.Tests.runtimeconfig.json xunit.console.dll System.Windows.Forms.Tests.dll -noautoreporters -xml testResults.xml'
        EnableXUnitReporter: true # required for reporting out xUnit test results to Mission Control
        IncludeDotNetCli: true # install the dot net cli
        DotNetCliPackageType: sdk
        DotNetCliVersion: 2.1.403

    - task: PublishBuildArtifacts@1
      displayName: Publish Logs to VSTS
      inputs:
        PathtoPublish: '$(Build.SourcesDirectory)/artifacts/log/$(_BuildConfig)'
        PublishLocation: Container
        ArtifactName: $(Agent.Os)_$(Agent.JobName)
      continueOnError: true
      condition: always()